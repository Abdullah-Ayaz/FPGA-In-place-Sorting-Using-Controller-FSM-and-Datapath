# FPGA-In-place-Sorting-Using-Controller-FSM-and-Datapath
This project focuses on the concept of in-place sorting of array elements in RAM. The project uses FSM logic to generate signals for the controller that guide the memory operations in the Datapath. At the end, we receive the  sorted array in memory with the smallest number as the first element and the largest number as the last element.

ðŸ”¹ Approach

The approach followed in this project is based on the classic hardware design methodology of datapath + control. Instead of writing a single large Verilog block, the sorting algorithm was broken down into building blocks: the datapath handles computations and storage, while the controller FSM manages sequencing and control flow. The sorter_top module then integrates both units along with memory to form a complete sorting system. This modularity not only simplifies debugging but also reflects how real-world processors and accelerators are designed.

ðŸ”¹ Datapath Design

The datapath is responsible for all operations involving registers, counters, and data flow. It includes two registers, A and B, which temporarily hold the elements of the array being compared. Two counters, i and j, are implemented to mimic the nested loop structure of bubble sort. A comparator checks whether A > B, and zero-detection logic generates loop-end signals (zi and zj). Multiplexers control whether memory addressing uses i or j, and whether data written back to memory comes from A or B. The datapath itself does not implement the sorting algorithm directly; instead, it provides flexible building blocks that the controller can orchestrate.

ðŸ”¹ Controller FSM Design

The controller is designed as a finite state machine (FSM) that drives the datapath. It progresses through states corresponding to the steps of the bubble sort algorithm: loading registers, comparing values, performing swaps, and incrementing counters. Control signals such as EA, EB, WR, Li, Lj, Ei, Ej, Csel, and Bout are generated by the FSM depending on the current state. By sequencing these signals correctly, the FSM ensures that the datapath executes bubble sort exactly as intended. The FSM ends in a done state, where the system signals that the sorting operation has finished.

ðŸ”¹ Integration (sorter_top.v)

The sorter_top module brings together the datapath, the controller, and the memory array into one system. The memory is initialized with unsorted values and acts as the array to be sorted. The datapath reads from and writes to this memory, while the controller orchestrates the sorting steps. A start signal (s) begins the sorting process, and the done output goes high once the sorting is complete. This integration module ensures smooth communication between all subsystems, making it the central unit of the design.

ðŸ”¹ Testbench

The testbench is designed to simulate the entire sorting system. It provides a clock signal and reset logic, and asserts the start signal to begin sorting. Once the done flag is raised, the testbench prints the final memory contents to the console so the results can be verified. Additionally, waveform dumping is supported for use in simulation tools like ModelSim, which allows detailed observation of signals such as register values, counters, memory contents, and FSM states. This makes debugging and verification straightforward.

ðŸ”¹ Simulation

The project was simulated in EDA playground. The waveforms illustrate how the datapath and controller interact step by step: registers A and B are updated, comparisons are made, memory is conditionally swapped, and counters increment until the array is sorted. The simulation confirms that the bubble sort algorithm is correctly mapped into hardware. Observing the memory values over time clearly shows the transformation from an unsorted to a sorted array, validating the correctness of the design.

ðŸ”¹ Key Takeaways

This project shows how a high-level algorithm like bubble sort can be implemented using a datapath + control FSM architecture. The modular design improves clarity, makes debugging easier, and provides a reusable framework for other algorithms. The separation of concerns mirrors how real processors are designed, where datapath handles computations while control governs sequencing. Overall, the project highlights how hardware sorting can be systematically approached and verified through simulation

